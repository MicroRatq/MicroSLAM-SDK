diff --git a/drivers/usb/typec/tcpm/tcpci_husb311.c b/drivers/usb/typec/tcpm/tcpci_husb311.c
index c6e2f45be..b52343687 100644
--- a/drivers/usb/typec/tcpm/tcpci_husb311.c
+++ b/drivers/usb/typec/tcpm/tcpci_husb311.c
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/regmap.h>
+#include <linux/workqueue.h>
 #include <linux/regulator/consumer.h>
 #include <linux/usb/tcpci.h>
 #include <linux/usb/tcpm.h>
@@ -45,6 +46,11 @@ static int husb311_read8(struct husb311_chip *chip, unsigned int reg, u8 *val)
 	return regmap_raw_read(chip->data.regmap, reg, val, sizeof(u8));
 }
 
+static int husb311_read16(struct husb311_chip *chip, unsigned int reg, u16 *val)
+{
+	return regmap_raw_read(chip->data.regmap, reg, val, sizeof(u16));
+}
+
 static int husb311_write8(struct husb311_chip *chip, unsigned int reg, u8 val)
 {
 	return regmap_raw_write(chip->data.regmap, reg, &val, sizeof(u8));
@@ -79,6 +85,9 @@ static int husb311_disable_osc24m(struct husb311_chip *chip)
 	if (ret < 0)
 		return ret;
 
+	dev_info(chip->dev, "pm: disable osc24m (POWER 0x%02x -> 0x%02x)\n",
+		 pwr, (u8)(pwr & ~BIT(0)));
+
 	pwr &= ~BIT(0);
 	ret = husb311_write8(chip, HUSB311_TCPC_POWER, pwr);
 	if (ret < 0)
@@ -94,6 +103,10 @@ static void husb311_pm_work(struct work_struct *work)
 
 	mutex_lock(&chip->lock);
 
+	dev_info(chip->dev, "pm_work: vbus_on=%d charge_on=%d suspended=%d disable_osc24m_ps=%d\n",
+		 chip->vbus_on, chip->charge_on, chip->suspended,
+		 chip->disable_osc24m_power_saving);
+
 	if (!chip->vbus_on && !chip->charge_on) {
 		if (chip->suspended)
 			goto exit;
@@ -147,6 +160,9 @@ static int husb311_set_vbus(struct tcpci *tcpci, struct tcpci_data *tdata,
 	struct husb311_chip *chip = tdata_to_husb311(tdata);
 	int ret = 0;
 
+	dev_info(chip->dev, "set_vbus: on=%d charge=%d (cur vbus_on=%d charge_on=%d)\n",
+		 on, charge, chip->vbus_on, chip->charge_on);
+
 	mutex_lock(&chip->lock);
 
 	if (chip->vbus_on == on) {
@@ -173,6 +189,8 @@ static int husb311_set_vbus(struct tcpci *tcpci, struct tcpci_data *tdata,
 		chip->charge_on = charge;
 
 	queue_delayed_work(system_freezable_wq, &chip->pm_work, HUSB311_PM_DELAY_S);
+	dev_info(chip->dev, "set_vbus: queued pm_work in %u ms\n",
+		 jiffies_to_msecs(HUSB311_PM_DELAY_S));
 
 done:
 	mutex_unlock(&chip->lock);
@@ -185,9 +203,21 @@ static irqreturn_t husb311_irq(int irq, void *dev_id)
 	enum typec_cc_status cc1, cc2;
 	u8 reg, role_ctrl;
 	u8 status;
+	u16 alert = 0, alert_after = 0;
+	u16 alert_mask = 0;
+	int ret;
+	irqreturn_t irqret;
+
+	ret = husb311_read16(chip, TCPC_ALERT, &alert);
+	if (ret < 0)
+		dev_err(chip->dev, "irq: failed to read TCPC_ALERT (%d)\n", ret);
+	ret = husb311_read16(chip, TCPC_ALERT_MASK, &alert_mask);
+	if (ret < 0)
+		dev_err(chip->dev, "irq: failed to read TCPC_ALERT_MASK (%d)\n", ret);
 
 	husb311_read8(chip, TCPC_ALERT, &status);
-	dev_dbg(chip->dev, "status 0x%02x", status);
+	dev_info(chip->dev, "irq=%d: ALERT=0x%04x (lo=0x%02x) MASK=0x%04x\n",
+		 irq, alert, status, alert_mask);
 
 	/*
 	 * If husb311 detects one of CC is Rp, let do clear the another CC
@@ -206,13 +236,18 @@ static irqreturn_t husb311_irq(int irq, void *dev_id)
 					 reg & TCPC_CC_STATUS_TERM ||
 					 tcpc_presenting_rd(role_ctrl, CC2));
 
-		dev_dbg(chip->dev, "CC1 %u, CC2 %u", cc1, cc2);
+		dev_info(chip->dev, "cc_change: ROLE_CTRL=0x%02x CC_STATUS=0x%02x -> CC1=%u CC2=%u\n",
+			 role_ctrl, reg, cc1, cc2);
 		if (cc1 == TYPEC_CC_RP_DEF) {
 			role_ctrl |= TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC2_SHIFT;
 			husb311_write8(chip, TCPC_ROLE_CTRL, role_ctrl);
+			dev_info(chip->dev, "cc_workaround: CC1=RP_DEF -> force CC2 OPEN (ROLE_CTRL=0x%02x)\n",
+				 role_ctrl);
 		} else if (cc2 == TYPEC_CC_RP_DEF) {
 			role_ctrl |= TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC1_SHIFT;
 			husb311_write8(chip, TCPC_ROLE_CTRL, role_ctrl);
+			dev_info(chip->dev, "cc_workaround: CC2=RP_DEF -> force CC1 OPEN (ROLE_CTRL=0x%02x)\n",
+				 role_ctrl);
 		}
 	}
 
@@ -220,7 +255,16 @@ static irqreturn_t husb311_irq(int irq, void *dev_id)
 	if (status & (TCPC_ALERT_TX_SUCCESS | TCPC_ALERT_TX_DISCARDED | TCPC_ALERT_TX_FAILED))
 		husb311_write8(chip, TCPC_COMMAND, 0xdd);
 
-	return tcpci_irq(chip->tcpci);
+	irqret = tcpci_irq(chip->tcpci);
+
+	ret = husb311_read16(chip, TCPC_ALERT, &alert_after);
+	if (ret < 0)
+		dev_err(chip->dev, "irq: failed to read TCPC_ALERT(after) (%d)\n", ret);
+	else
+		dev_info(chip->dev, "irq: tcpci_irq ret=%d, ALERT(after)=0x%04x\n",
+			 irqret, alert_after);
+
+	return irqret;
 }
 
 static int husb311_check_revision(struct i2c_client *i2c)
@@ -314,6 +358,11 @@ static int husb311_probe(struct i2c_client *client,
 		device_property_read_bool(chip->dev, "hynetek,disable-osc24m-power-saving");
 	device_init_wakeup(chip->dev, true);
 
+	dev_info(chip->dev,
+		 "probe: irq=%d vbus_reg=%s wakeup_source=%d disable_osc24m_ps=%d\n",
+		 client->irq, chip->vbus ? "yes" : "no",
+		 chip->wakeup, chip->disable_osc24m_power_saving);
+
 	return 0;
 }
 
@@ -347,6 +396,10 @@ static int husb311_pm_suspend(struct device *dev)
 	else
 		disable_irq(client->irq);
 
+	dev_info(chip->dev, "pm_suspend: may_wakeup=%d vbus_on=%d wakeup_source=%d -> irq=%d (%s)\n",
+		 device_may_wakeup(dev), chip->vbus_on, chip->wakeup, client->irq,
+		 (device_may_wakeup(dev) && (!chip->vbus_on || chip->wakeup)) ? "irq_wake" : "irq_disabled");
+
 	if (!chip->suspended) {
 		chip->suspended = 1;
 		if (!chip->disable_osc24m_power_saving)
@@ -407,6 +460,10 @@ static int husb311_pm_resume(struct device *dev)
 	else
 		enable_irq(client->irq);
 
+	dev_info(chip->dev, "pm_resume: may_wakeup=%d vbus_on=%d wakeup_source=%d -> irq=%d (%s)\n",
+		 device_may_wakeup(dev), chip->vbus_on, chip->wakeup, client->irq,
+		 (device_may_wakeup(dev) && (!chip->vbus_on || chip->wakeup)) ? "disable_irq_wake" : "enable_irq");
+
 	/*
 	 * When the power of husb311 is lost or i2c read failed in PM S/R
 	 * process, we must reset the tcpm port first to ensure the devices
@@ -416,6 +473,8 @@ static int husb311_pm_resume(struct device *dev)
 	 * husb311 powered off in suspend, the value would reset to default.
 	 */
 	ret = husb311_read8(chip, HUSB311_TCPC_FILTER, &filter);
+	dev_info(chip->dev, "pm_resume: FILTER=0x%02x ret=%d altmode_registered=%d\n",
+		 filter, ret, is_partner_altmode_device_registered(dev));
 	if (filter != 0x0F || ret < 0 || is_partner_altmode_device_registered(dev)) {
 		ret = husb311_sw_reset(chip);
 		if (ret < 0) {
